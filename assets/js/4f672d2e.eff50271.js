"use strict";(self.webpackChunklakesoul_website=self.webpackChunklakesoul_website||[]).push([[2333],{4508:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>n,toc:()=>s});const n=JSON.parse('{"id":"Usage Docs/clean-redundant-data","title":"LakeSoul Table Lifecycle Automatic Maintenance and Redundant Data Automatic Cleaning","description":"This feature is available starting from version 2.4.0 to 2.6.0. For 3.0 version and above, it is recommended to use Async Clean Service.","source":"@site/docs/03-Usage Docs/09-clean-redundant-data.md","sourceDirName":"03-Usage Docs","slug":"/Usage Docs/clean-redundant-data","permalink":"/docs/Usage Docs/clean-redundant-data","draft":false,"unlisted":false,"editUrl":"https://github.com/lakesoul-io/LakeSoul/tree/main/website/docs/03-Usage Docs/09-clean-redundant-data.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"LakeSoul Global Automatic Compaction Service Usage","permalink":"/docs/Usage Docs/auto-compaction-task"},"next":{"title":"Use Presto to Query LakeSoul\'s Table","permalink":"/docs/Usage Docs/setup-presto"}}');var i=t(4848),o=t(8453);const l={},r="LakeSoul Table Lifecycle Automatic Maintenance and Redundant Data Automatic Cleaning",c={},s=[{value:"Manually Clean Up Old Compaction Data",id:"manually-clean-up-old-compaction-data",level:2},{value:"Automatically Clean Up Expired Data and Redundant Data",id:"automatically-clean-up-expired-data-and-redundant-data",level:2},{value:"Configure Partition Lifecycle via <code>partition.ttl</code> table property",id:"configure-partition-lifecycle-via-partitionttl-table-property",level:3},{value:"Configure Lifecycle of Redundant Data via <code>compaction.ttl</code> table property",id:"configure-lifecycle-of-redundant-data-via-compactionttl-table-property",level:3},{value:"Configuration Examples",id:"configuration-examples",level:3},{value:"Specify configuration when writing through data",id:"specify-configuration-when-writing-through-data",level:4},{value:"Add or modify the configuration through API",id:"add-or-modify-the-configuration-through-api",level:3},{value:"Execute a job that automatically cleans expired data in all tables",id:"execute-a-job-that-automatically-cleans-expired-data-in-all-tables",level:3}];function d(e){const a={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.header,{children:(0,i.jsx)(a.h1,{id:"lakesoul-table-lifecycle-automatic-maintenance-and-redundant-data-automatic-cleaning",children:"LakeSoul Table Lifecycle Automatic Maintenance and Redundant Data Automatic Cleaning"})}),"\n",(0,i.jsx)(a.admonition,{type:"tip",children:(0,i.jsxs)(a.p,{children:["This feature is available starting from version 2.4.0 to 2.6.0. For 3.0 version and above, it is recommended to use ",(0,i.jsx)(a.a,{href:"/docs/Usage%20Docs/new-async-clean-service",children:"Async Clean Service"}),"."]})}),"\n",(0,i.jsx)(a.p,{children:"In a data warehouse, it is usually necessary to set the life cycle of table data to save space and reduce costs."}),"\n",(0,i.jsx)(a.p,{children:"On the other hand, for tables that are updated in real time, there will also be redundant data. Redundant data means that every time a compaction operation is performed, a new compaction file will be generated. The new compaction file contains all historical data. At this time, all historical compaction files can be regarded as redundant data."}),"\n",(0,i.jsx)(a.p,{children:"At the same time, for a table data that is continuously updated and compaction operated. If the user only cares about the data changes at a certain time recently. At this time, users can choose to clean up all data before a certain compaction, which will retain a full copy of the data and support users' incremental and snapshot reads from a recent time."}),"\n",(0,i.jsx)(a.h2,{id:"manually-clean-up-old-compaction-data",children:"Manually Clean Up Old Compaction Data"}),"\n",(0,i.jsx)(a.p,{children:"When performing a compactition operation, users can turn on the switch cleanOldCompaction=true to clean up old compaction file data. Default is false."}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:"     LakeSoulTable.forPath(tablePath).compaction(true)\n"})}),"\n",(0,i.jsx)(a.h2,{id:"automatically-clean-up-expired-data-and-redundant-data",children:"Automatically Clean Up Expired Data and Redundant Data"}),"\n",(0,i.jsx)(a.p,{children:"Users can configure the following two table properties:"}),"\n",(0,i.jsxs)(a.ol,{children:["\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.code,{children:"partition.ttl"})," represents the partition expiration time, unit is days."]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.code,{children:"compaction.ttl"})," represents the expiration time of redundant data, unit is days."]}),"\n"]}),"\n",(0,i.jsxs)(a.h3,{id:"configure-partition-lifecycle-via-partitionttl-table-property",children:["Configure Partition Lifecycle via ",(0,i.jsx)(a.code,{children:"partition.ttl"})," table property"]}),"\n",(0,i.jsx)(a.p,{children:"As for the expiration time of table partitions, assuming that the user configures it to 365 days, then in the table, if the latest commit record of a partition has expired, the partition data will be deleted. In particular, if all partitions of the table are expired, it is equivalent to executing the truncate function."}),"\n",(0,i.jsxs)(a.h3,{id:"configure-lifecycle-of-redundant-data-via-compactionttl-table-property",children:["Configure Lifecycle of Redundant Data via ",(0,i.jsx)(a.code,{children:"compaction.ttl"})," table property"]}),"\n",(0,i.jsx)(a.p,{children:"Clean up redundant data in partitions. Assume that the redundant cleanup lasts for 3 days, then find the latest compaction 3 days ago and delete the data before it. The purpose is that snapshot reads and incremental reads within 3 days are all valid."}),"\n",(0,i.jsx)(a.h3,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,i.jsxs)(a.p,{children:["Users can set ",(0,i.jsx)(a.code,{children:"partition.ttl"})," and ",(0,i.jsx)(a.code,{children:"compaction.ttl"})," in the following ways."]}),"\n",(0,i.jsx)(a.h4,{id:"specify-configuration-when-writing-through-data",children:"Specify configuration when writing through data"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:'     val df = Seq(("2021-01-01", 1, "rice"), ("2021-01-01", 2, "bread")).toDF("date", "id", "name ")\n     val tablePath = "s3a://bucket-name/table/path/is/also/table/name"\n     df.write\n       .mode("append")\n       .format("lakesoul")\n       .option("rangePartitions", "date")\n       .option("hashPartitions", "id")\n       .option("partition.ttl",365)\n       .option("compaction.ttl",3)\n       .option("hashBucketNum", "2")\n       .save(tablePath)\n'})}),"\n",(0,i.jsxs)(a.p,{children:["You can also add property configuration in ",(0,i.jsx)(a.code,{children:"TBLPROPERTIES"})," in the ",(0,i.jsx)(a.code,{children:"CREATE TABLE"})," SQL statement (in Flink, property configuration is added after ",(0,i.jsx)(a.code,{children:"WITH"}),"). Examples:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-sql",children:"-- For Spark\nCREATE TABLE table (id INT, data STRING) USING lakesoul\n    TBLPROPERTIES ('partition.ttl'='365', 'compaction.ttl'='7')\n\n-- For Flink\ncreate table `lakesoul`.`default`.test_table (`id` INT, data STRING,\n                                              PRIMARY KEY (`id`,`name`) NOT ENFORCED)\nWITH (\n    'connector'='lakesoul',\n    'hashBucketNum'='4',\n    'use_cdc'='true',\n    'partition.ttl'='365',\n    'compaction.ttl'='7',\n    'path'='file:///tmp/lakesoul/flink/sink/test');\n"})}),"\n",(0,i.jsx)(a.h3,{id:"add-or-modify-the-configuration-through-api",children:"Add or modify the configuration through API"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:"     LakeSoulTable.forPath(tablePath).setPartitionTtl(128).setCompactionTtl(10)\n"})}),"\n",(0,i.jsx)(a.p,{children:"At the same time, the configuration can be canceled through tableAPI"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-scala",children:"     LakeSoulTable.forPath(tablePath).cancelPartitionTtl()\n     LakeSoulTable.forPath(tablePath).cancelCompactionTtl()\n"})}),"\n",(0,i.jsxs)(a.p,{children:["Configure the LakeSoul metabase connection for Spark jobs. For detailed instructions, please refer to ",(0,i.jsx)(a.a,{href:"/docs/Usage%20Docs/setup-spark",children:"LakeSoul Setup Spark Project/Job"}),";"]}),"\n",(0,i.jsx)(a.h3,{id:"execute-a-job-that-automatically-cleans-expired-data-in-all-tables",children:"Execute a job that automatically cleans expired data in all tables"}),"\n",(0,i.jsx)(a.p,{children:"LakeSoul provides a Spark job implementation for cleaning expired data. It will scan all expired partitions in the metadata and perform cleaning. Users can schedule this task regularly at the daily level to achieve the purpose of cleaning."}),"\n",(0,i.jsx)(a.p,{children:"Start the Spark cleanup command locally:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-shell",children:"./bin/spark-submit \\\n     --name clean_redundant_data \\\n     --master yarn \\\n     --deploy-mode cluster \\\n     --executor-memory 3g \\\n     --executor-cores 1 \\\n     --num-executors 20 \\\n     --class com.dmetasoul.lakesoul.spark.clean.CleanExpiredData \\\n     jars/lakesoul-spark-3.3-3.0.0.jar\n\n"})}),"\n",(0,i.jsx)(a.admonition,{type:"tip",children:(0,i.jsx)(a.p,{children:"The above cleaning tasks are effective for all LakeSoul tables."})})]})}function u(e={}){const{wrapper:a}={...(0,o.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,a,t)=>{t.d(a,{R:()=>l,x:()=>r});var n=t(6540);const i={},o=n.createContext(i);function l(e){const a=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),n.createElement(o.Provider,{value:a},e.children)}}}]);