"use strict";(self.webpackChunklakesoul_website=self.webpackChunklakesoul_website||[]).push([[4006],{5309:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>u,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var n=t(5893),r=t(1151),l=t(4866),o=t(5162);const s={},i="Use LakeSoul CDC Table Format",c={id:"Usage Docs/cdc-ingestion-table",title:"Use LakeSoul CDC Table Format",description:"\x3c!--",source:"@site/docs/03-Usage Docs/04-cdc-ingestion-table.mdx",sourceDirName:"03-Usage Docs",slug:"/Usage Docs/cdc-ingestion-table",permalink:"/docs/Usage Docs/cdc-ingestion-table",draft:!1,unlisted:!1,editUrl:"https://github.com/lakesoul-io/LakeSoul/tree/main/website/docs/03-Usage Docs/04-cdc-ingestion-table.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Spark API Docs",permalink:"/docs/Usage Docs/spark-api-docs"},next:{title:"Synchronization of Entire Database into LakeSoul",permalink:"/docs/Usage Docs/flink-cdc-sync"}},u={},d=[{value:"Create LakeSoul Table with CDC Format",id:"create-lakesoul-table-with-cdc-format",level:2},{value:"In Spark",id:"in-spark",level:3},{value:"In Flink",id:"in-flink",level:3},{value:"Incremental Read for LakeSoul CDC Table",id:"incremental-read-for-lakesoul-cdc-table",level:2}];function h(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.h1,{id:"use-lakesoul-cdc-table-format",children:"Use LakeSoul CDC Table Format"}),"\n",(0,n.jsx)(a.p,{children:"CDC (Change Data Capture) is an important data source for Lakehouse. The goal of LakeSoul CDC table format is to sync the change of online OLTP database into LakeSoul in a very low latency, usually several minutes, manner so that the downstream analytics could get the newest results as soon as possible without the need of tranditional T+1 database dump. Compared to normal table, CDC table format supports delete row capability."}),"\n",(0,n.jsxs)(a.p,{children:["LakeSoul uses an extra change operation column (column name is configurable) to model the CDC data and can consume the CDC sources including ",(0,n.jsx)(a.a,{href:"https://debezium.io/",children:"Debezium"}),", ",(0,n.jsx)(a.a,{href:"https://github.com/alibaba/canal",children:"canal"})," as well as ",(0,n.jsx)(a.a,{href:"https://github.com/ververica/flink-cdc-connectors",children:"Flink CDC"}),". By default LakeSoul would not enable this format, that means normal table would only support upsert operations, but not delete. To enable CDC format, you need to add extra property to enable it when creating table."]}),"\n",(0,n.jsxs)(a.p,{children:["To create a LakeSoul CDC table, add a table property ",(0,n.jsx)(a.code,{children:"lakesoul_cdc_change_column"})," with the column name that records the change type. This column should be of ",(0,n.jsx)(a.code,{children:"string"})," type and contains one of the three values: ",(0,n.jsx)(a.code,{children:"update"}),", ",(0,n.jsx)(a.code,{children:"insert"}),", ",(0,n.jsx)(a.code,{children:"delete"}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["During the automatic merging phase of LakeSoul batch read data (including using Spark/Flink batch read), the latest ",(0,n.jsx)(a.code,{children:"insert"}),", ",(0,n.jsx)(a.code,{children:"update"})," data will be kept, and ",(0,n.jsx)(a.code,{children:"delete"})," rows will be automatically filtered out. When using Spark/Flink streaming incremental reading, the value of the CDC change column (including ",(0,n.jsx)(a.code,{children:"insert"}),", ",(0,n.jsx)(a.code,{children:"update"}),", ",(0,n.jsx)(a.code,{children:"delete"}),") will be retained. In Flink, this column will be automatically converted to corresponding value of the RowKind field of the RowData class object, so that LakeSoul fully supports the Flink Changelog Stream semantics during Flink stream reading, and can perform incremental calculations."]}),"\n",(0,n.jsx)(a.h2,{id:"create-lakesoul-table-with-cdc-format",children:"Create LakeSoul Table with CDC Format"}),"\n",(0,n.jsx)(a.h3,{id:"in-spark",children:"In Spark"}),"\n",(0,n.jsxs)(a.p,{children:["Use Scala API or SQL, assuming change operation column name is ",(0,n.jsx)(a.code,{children:"change_type"}),":"]}),"\n",(0,n.jsxs)(l.Z,{defaultValue:"Scala",values:[{label:"Scala",value:"Scala"},{label:"SQL",value:"SQL"}],children:[(0,n.jsx)(o.Z,{value:"Scala",children:(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-scala",children:'import com.dmetasoul.lakesoul.tables.LakeSoulTable\nLakeSoulTable.createTable(data, path).shortTableName("cdc_ingestion").hashPartitions("id").hashBucketNum(2).rangePartitions("rangeid").tableProperty("lakesoul_cdc_change_column" -> "change_type").create()\n'})})}),(0,n.jsx)(o.Z,{value:"SQL",children:(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-sql",children:"CREATE TABLE table_name (id string, date string, change_type string) USING lakesoul\n  PARTITIONED BY (date)\n  LOCATION 's3://lakesoul-bucket/table_path'\n  TBLPROPERTIES('lakesoul_cdc_change_column'='change_type',\n    'hashPartitions'='id',\n    'hashBucketNum'='2');\n"})})})]}),"\n",(0,n.jsx)(a.p,{children:"Note that LakeSoul CDC ingestion table must have primary key(s) and the primary keys(s) should be the same with the online OLTP table."}),"\n",(0,n.jsx)(a.h3,{id:"in-flink",children:"In Flink"}),"\n",(0,n.jsxs)(a.p,{children:["Please refer to ",(0,n.jsx)(a.a,{href:"/docs/Usage%20Docs/flink-lakesoul-connector",children:"Flink Connector"})]}),"\n",(0,n.jsx)(a.h2,{id:"incremental-read-for-lakesoul-cdc-table",children:"Incremental Read for LakeSoul CDC Table"}),"\n",(0,n.jsx)(a.p,{children:"The LakeSoul adopts the primary key sharding mode for incremental upsert, so the incremental data does not need to be merged with the stock data when writing. For CDC tables, the delta data is the content of the original CDC stream. The CDC incremental read of the LakeSoul table can fully retain the CDC operation flags, namely insert, update, and delete."}),"\n",(0,n.jsx)(a.p,{children:"Version 2.2.0 supports incremental streaming reading in Spark."}),"\n",(0,n.jsxs)(a.p,{children:["From version 2.3.0, Flink Table Source is supported, and streaming incremental reading/writing is supported for Flink ChangeLog Stream semantics, please refer to ",(0,n.jsx)(a.a,{href:"/docs/Usage%20Docs/flink-lakesoul-connector",children:"Flink Connector"})," ."]})]})}function m(e={}){const{wrapper:a}={...(0,r.a)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},5162:(e,a,t)=>{t.d(a,{Z:()=>o});t(7294);var n=t(6905);const r={tabItem:"tabItem_Ymn6"};var l=t(5893);function o(e){let{children:a,hidden:t,className:o}=e;return(0,l.jsx)("div",{role:"tabpanel",className:(0,n.Z)(r.tabItem,o),hidden:t,children:a})}},4866:(e,a,t)=>{t.d(a,{Z:()=>y});var n=t(7294),r=t(6905),l=t(2466),o=t(6550),s=t(469),i=t(1980),c=t(7392),u=t(12);function d(e){return n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:a}=e;return!!a&&"object"==typeof a&&"value"in a}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:a,children:t}=e;return(0,n.useMemo)((()=>{const e=a??function(e){return d(e).map((e=>{let{props:{value:a,label:t,attributes:n,default:r}}=e;return{value:a,label:t,attributes:n,default:r}}))}(t);return function(e){const a=(0,c.l)(e,((e,a)=>e.value===a.value));if(a.length>0)throw new Error(`Docusaurus error: Duplicate values "${a.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[a,t])}function m(e){let{value:a,tabValues:t}=e;return t.some((e=>e.value===a))}function p(e){let{queryString:a=!1,groupId:t}=e;const r=(0,o.k6)(),l=function(e){let{queryString:a=!1,groupId:t}=e;if("string"==typeof a)return a;if(!1===a)return null;if(!0===a&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:a,groupId:t});return[(0,i._X)(l),(0,n.useCallback)((e=>{if(!l)return;const a=new URLSearchParams(r.location.search);a.set(l,e),r.replace({...r.location,search:a.toString()})}),[l,r])]}function b(e){const{defaultValue:a,queryString:t=!1,groupId:r}=e,l=h(e),[o,i]=(0,n.useState)((()=>function(e){let{defaultValue:a,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(a){if(!m({value:a,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${a}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return a}const n=t.find((e=>e.default))??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:a,tabValues:l}))),[c,d]=p({queryString:t,groupId:r}),[b,f]=function(e){let{groupId:a}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(a),[r,l]=(0,u.Nk)(t);return[r,(0,n.useCallback)((e=>{t&&l.set(e)}),[t,l])]}({groupId:r}),g=(()=>{const e=c??b;return m({value:e,tabValues:l})?e:null})();(0,s.Z)((()=>{g&&i(g)}),[g]);return{selectedValue:o,selectValue:(0,n.useCallback)((e=>{if(!m({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);i(e),d(e),f(e)}),[d,f,l]),tabValues:l}}var f=t(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var k=t(5893);function v(e){let{className:a,block:t,selectedValue:n,selectValue:o,tabValues:s}=e;const i=[],{blockElementScrollPositionUntilNextRender:c}=(0,l.o5)(),u=e=>{const a=e.currentTarget,t=i.indexOf(a),r=s[t].value;r!==n&&(c(a),o(r))},d=e=>{let a=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=i.indexOf(e.currentTarget)+1;a=i[t]??i[0];break}case"ArrowLeft":{const t=i.indexOf(e.currentTarget)-1;a=i[t]??i[i.length-1];break}}a?.focus()};return(0,k.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":t},a),children:s.map((e=>{let{value:a,label:t,attributes:l}=e;return(0,k.jsx)("li",{role:"tab",tabIndex:n===a?0:-1,"aria-selected":n===a,ref:e=>i.push(e),onKeyDown:d,onClick:u,...l,className:(0,r.Z)("tabs__item",g.tabItem,l?.className,{"tabs__item--active":n===a}),children:t??a},a)}))})}function x(e){let{lazy:a,children:t,selectedValue:r}=e;const l=(Array.isArray(t)?t:[t]).filter(Boolean);if(a){const e=l.find((e=>e.props.value===r));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return(0,k.jsx)("div",{className:"margin-top--md",children:l.map(((e,a)=>(0,n.cloneElement)(e,{key:a,hidden:e.props.value!==r})))})}function C(e){const a=b(e);return(0,k.jsxs)("div",{className:(0,r.Z)("tabs-container",g.tabList),children:[(0,k.jsx)(v,{...e,...a}),(0,k.jsx)(x,{...e,...a})]})}function y(e){const a=(0,f.Z)();return(0,k.jsx)(C,{...e,children:d(e.children)},String(a))}},1151:(e,a,t)=>{t.d(a,{Z:()=>s,a:()=>o});var n=t(7294);const r={},l=n.createContext(r);function o(e){const a=n.useContext(l);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function s(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(l.Provider,{value:a},e.children)}}}]);