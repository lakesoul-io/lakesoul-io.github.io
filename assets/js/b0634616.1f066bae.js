"use strict";(self.webpackChunklakesoul_website=self.webpackChunklakesoul_website||[]).push([[4844],{5402:(e,t,l)=>{l.r(t),l.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>o});var s=l(5893),n=l(1151);const r={},a="Multi Stream Merge to Build Wide Table Tutorial",i={id:"Tutorials/mutil-stream-merge",title:"Multi Stream Merge to Build Wide Table Tutorial",description:"\x3c!--",source:"@site/docs/02-Tutorials/06-mutil-stream-merge.md",sourceDirName:"02-Tutorials",slug:"/Tutorials/mutil-stream-merge",permalink:"/docs/Tutorials/mutil-stream-merge",draft:!1,unlisted:!1,editUrl:"https://github.com/lakesoul-io/LakeSoul/tree/main/website/docs/02-Tutorials/06-mutil-stream-merge.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Upsert Data and Merge UDF Tutorial",permalink:"/docs/Tutorials/upsert-and-merge-udf"},next:{title:"Multiple Kafka Topics Data to LakeSoul Tutorial",permalink:"/docs/Tutorials/kafka-topics-data-to-lakesoul"}},d={},o=[];function h(e){const t={code:"code",h1:"h1",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"multi-stream-merge-to-build-wide-table-tutorial",children:"Multi Stream Merge to Build Wide Table Tutorial"}),"\n",(0,s.jsx)(t.p,{children:"To build wide table, traditional data warehouse or ETL uses multi tables join according to the primary and foreign key. When there is a large amount of data or multiple joins are required, there will be problems such as low efficiency, large memory consumption, and even OOM. In addition, the Shuffle process takes up most of the data exchange time, and is inefficient. LakeSoul has supported upsert with merge operator, which can be used to implement multi stream merge in realtime, and avoid the above problems by eliminating join and shuffle. The following is a specific example of this scenario."}),"\n",(0,s.jsx)(t.p,{children:"Suppose there are data of the following streams, A, B, C and D. The data contents of each stream are as follows:"}),"\n",(0,s.jsx)(t.p,{children:"A:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Ip"}),(0,s.jsx)(t.th,{children:"sy"}),(0,s.jsx)(t.th,{children:"us"})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"1.1.1.1"}),(0,s.jsx)(t.td,{children:"30"}),(0,s.jsx)(t.td,{children:"40"})]})})]}),"\n",(0,s.jsx)(t.p,{children:"B:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Ip"}),(0,s.jsx)(t.th,{children:"free"}),(0,s.jsx)(t.th,{children:"cache"})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"1.1.1.1"}),(0,s.jsx)(t.td,{children:"1677"}),(0,s.jsx)(t.td,{children:"455"})]})})]}),"\n",(0,s.jsx)(t.p,{children:"C:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Ip"}),(0,s.jsx)(t.th,{children:"level"}),(0,s.jsx)(t.th,{children:"des"})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"1.1.1.2"}),(0,s.jsx)(t.td,{children:"error"}),(0,s.jsx)(t.td,{children:"killed"})]})})]}),"\n",(0,s.jsx)(t.p,{children:"D:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Ip"}),(0,s.jsx)(t.th,{children:"qps"}),(0,s.jsx)(t.th,{children:"tps"})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"1.1.1.1"}),(0,s.jsx)(t.td,{children:"30"}),(0,s.jsx)(t.td,{children:"40"})]})})]}),"\n",(0,s.jsx)(t.p,{children:"Finally, a large wide table needs to be formed, and the four tables need to be consolidated and displayed as follows:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"IP"}),(0,s.jsx)(t.th,{children:"sy"}),(0,s.jsx)(t.th,{children:"us"}),(0,s.jsx)(t.th,{children:"free"}),(0,s.jsx)(t.th,{children:"cache"}),(0,s.jsx)(t.th,{children:"level"}),(0,s.jsx)(t.th,{children:"des"}),(0,s.jsx)(t.th,{children:"qps"}),(0,s.jsx)(t.th,{children:"tps"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"1.1.1.1"}),(0,s.jsx)(t.td,{children:"30"}),(0,s.jsx)(t.td,{children:"40"}),(0,s.jsx)(t.td,{children:"1677"}),(0,s.jsx)(t.td,{children:"455"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"30"}),(0,s.jsx)(t.td,{children:"40"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"1.1.1.2"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"error"}),(0,s.jsx)(t.td,{children:"killed"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"null"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"Traditionally, to perform the above operations, four tables need to be joined three times according to the primary key (IP). The writing method is as follows:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"Select \n       A.IP as IP,  \n       A.sy as sy, \n       A.us as us, \n       B.free as free, \n       B.cache as cache, \n       C.level as level, \n       C.des as des, \n       D.qps as qps, \n       D.tps as tps \nfrom A join B on A.IP = B.IP \n    join C on C.IP = A.IP \n    join D on D.IP = A.IP.\n"})}),"\n",(0,s.jsx)(t.p,{children:"LakeSoul supports multi stream merge with different schemas (same primary keys should exist), and can automatically extend the schema of the table according to the primary key from multiple streams. If the newly written data field does not exist in the original table, it will automatically extend the table schema. The non-existent field is null by default. Therefore, the same resulting data can be achieved by writing each stream data to LakeSoul through upsert without table join. The above process code is implemented as follows:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'import org.apache.spark.sql._\nval spark = SparkSession.builder.master("local")\n  .config("spark.sql.extensions", "com.dmetasoul.lakesoul.sql.LakeSoulSparkSessionExtension")\n  .config("spark.dmetasoul.lakesoul.schema.autoMerge.enabled", "true")\n  .getOrCreate()\nimport spark.implicits._\n\nval df1 = Seq(("1.1.1.1", 30, 40)).toDF("IP", "sy", "us")\nval df2 = Seq(("1.1.1.1", 1677, 455)).toDF("IP", "free", "cache")\nval df3 = Seq(("1.1.1.2", "error", "killed")).toDF("IP", "level", "des")\nval df4 = Seq(("1.1.1.1", 30, 40)).toDF("IP", "qps", "tps")\n\nval tablePath = "s3a://bucket-name/table/path/is/also/table/name"\n\ndf1.write\n  .mode("append")\n  .format("lakesoul")\n  .option("hashPartitions","IP")\n  .option("hashBucketNum","2")\n  .save(tablePath)\n\nval lakeSoulTable = LakeSoulTable.forPath(tablePath)\n\nlakeSoulTable.upsert(df2)\nlakeSoulTable.upsert(df3)\nlakeSoulTable.upsert(df4)\nlakeSoulTable.toDF.show()\n\n/**\n *  result\n *  |  IP   |  sy|  us|free|cache|level|   des| qps| tps|\n *  +-------+----+----+----+-----+-----+------+----+----+\n *  |1.1.1.2|null|null|null| null|error|killed|null|null|\n *  |1.1.1.1|  30|  40|1677|  455| null|  null|  30|  40|\n *  +-------+----+----+----+-----+-----+------+----+----+\n */\n\n'})})]})}function c(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1151:(e,t,l)=>{l.d(t,{Z:()=>i,a:()=>a});var s=l(7294);const n={},r=s.createContext(n);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);