"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[39],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>h});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),p=c(a),d=o,h=p["".concat(l,".").concat(d)]||p[d]||u[d]||r;return a?n.createElement(h,i(i({ref:t},m),{},{components:a})):n.createElement(h,i({ref:t},m))}));function h(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},6324:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=a(7462),o=(a(7294),a(3905));const r={},i="LakeSoul Automatic Compaction Task",s={unversionedId:"Usage Docs/auto-compaction-task",id:"Usage Docs/auto-compaction-task",title:"LakeSoul Automatic Compaction Task",description:"Whether the data is written in batch or streaming tasks, the data is mostly written in merge mode, therefore there are some intermediate redundant data and a large number of small files. In order to reduce the waste of resources caused by such data and improve the efficiency of data reading, the data needs to be compressed.",source:"@site/docs/03-Usage Docs/08-auto-compaction-task.md",sourceDirName:"03-Usage Docs",slug:"/Usage Docs/auto-compaction-task",permalink:"/docs/Usage Docs/auto-compaction-task",draft:!1,editUrl:"https://github.com/lakesoul-io/LakeSoul/tree/main/website/docs/03-Usage Docs/08-auto-compaction-task.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"LakeSoul Flink Connector",permalink:"/docs/Usage Docs/flink-lakesoul-connector"}},l={},c=[{value:"Implementation mechanism",id:"implementation-mechanism",level:2},{value:"Compaction task startup tutorial",id:"compaction-task-startup-tutorial",level:2}],m={toc:c},p="wrapper";function u(e){let{components:t,...a}=e;return(0,o.kt)(p,(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"lakesoul-automatic-compaction-task"},"LakeSoul Automatic Compaction Task"),(0,o.kt)("p",null,"Whether the data is written in batch or streaming tasks, the data is mostly written in merge mode, therefore there are some intermediate redundant data and a large number of small files. In order to reduce the waste of resources caused by such data and improve the efficiency of data reading, the data needs to be compressed."),(0,o.kt)("p",null,"If we perform compaction in a writing job (such as a stream job), the main receiver process may be blocked. If we compress each table in a separate job, it will be inconvenient to set it. Therefore, we added the global classification automatic compaction task, which can automatically compress the data according to the database and write partition data."),(0,o.kt)("h2",{id:"implementation-mechanism"},"Implementation mechanism"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Depending on PG's trigger notify listen mechanism, define a trigger function in PLSQL in PG: each time data is written, it can trigger the execution of a defined function, analyze and process the partitions that meet the compaction conditions in the function (for example, there are 10 submissions since the last compaction), and then publish the information;"),(0,o.kt)("li",{parentName:"ul"},"The backend starts a real-time listening task to listen to the information published by PG, and then starts the spark task to compress the data of partitions that meet the compaction conditions.")),(0,o.kt)("p",null,"Currently, compaction is only performed according to the version of the written partition, and the execution of the compaction task will be triggered every 10 submissions."),(0,o.kt)("h2",{id:"compaction-task-startup-tutorial"},"Compaction task startup tutorial"),(0,o.kt)("p",null,"The trigger and pg functions have been configured when the database is initialized, and the default compaction configuration will trigger a compaction signal every time a partition is inserted 10 times, so you only need to start the spark automatic compaction job."),(0,o.kt)("p",null,"Download or decompress the LakeSoul project code, and then put the jar package in the $SPARK_HOME/jars directory, or add the dependent jar package through --jars when submitting the task, and then start the spark automatic compaction task."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Pass ",(0,o.kt)("inlineCode",{parentName:"li"},"lakesoul_home")," environment variable to your job. For detailed documentation, please refer\nto ",(0,o.kt)("a",{parentName:"li",href:"/docs/Getting%20Started/setup-local-env"},"Setup a local test environment")),(0,o.kt)("li",{parentName:"ol"},"Submit task. The currently supported parameters are as follows:")),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,o.kt)("th",{parentName:"tr",align:null},"Meaning"),(0,o.kt)("th",{parentName:"tr",align:null},"required"),(0,o.kt)("th",{parentName:"tr",align:null},"default"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"threadpool.size"),(0,o.kt)("td",{parentName:"tr",align:null},"the thread pools number of automatic compaction task"),(0,o.kt)("td",{parentName:"tr",align:null},"false"),(0,o.kt)("td",{parentName:"tr",align:null},"8")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"database"),(0,o.kt)("td",{parentName:"tr",align:null},"The database name to compress. If it is not filled, it means that all database partitions will compress that meet the conditions"),(0,o.kt)("td",{parentName:"tr",align:null},"false"),(0,o.kt)("td",{parentName:"tr",align:null},'""')))),(0,o.kt)("p",null,"the demo of starting the automatic compaction task command locally:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'export lakesoul_home=pg.properties && ./bin/spark-submit \\\n--name auto_compaction_task \\\n--master local[4]  \\\n--executor-memory 2g \\\n--conf "spark.driver.extraJavaOptions=-XX:MaxDirectMemorySize=8G" \\\n--class com.dmetasoul.lakesoul.spark.compaction.CompactionTask  \\\njars/lakesoul-spark-2.2.0-spark-3.3-SNAPSHOT.jar  --threadpool.size=10 --database=test\n')),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Because LakeSoul enables native IO by default and needs to rely on off-heap memory, the spark task needs to set the size of off-heap memory, otherwise it is prone to out-of-heap memory overflow.")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Your could enable Spark's dynamic allocation to get auto-scaling for the compaction job. Refer to Spark's doc ",(0,o.kt)("a",{parentName:"p",href:"https://spark.apache.org/docs/3.3.1/job-scheduling.html#dynamic-resource-allocation"},"Dynamic Resource Allocation")," on how to config.")))}u.isMDXComponent=!0}}]);