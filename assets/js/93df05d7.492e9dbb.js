"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>b});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),u=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=u(e.components);return n.createElement(i.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(a),m=r,b=d["".concat(i,".").concat(m)]||d[m]||p[m]||l;return a?n.createElement(b,o(o({ref:t},c),{},{components:a})):n.createElement(b,o({ref:t},c))}));function b(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,o=new Array(l);o[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var u=2;u<l;u++)o[u]=a[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},3894:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>N,contentTitle:()=>L,default:()=>_,frontMatter:()=>D,metadata:()=>E,toc:()=>I});var n=a(7462),r=a(7294),l=a(3905),o=a(6010),s=a(2466),i=a(6550),u=a(1980),c=a(7392),d=a(12);function p(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function m(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??p(a);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function b(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:a}=e;const n=(0,i.k6)(),l=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,u._X)(l),(0,r.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(n.location.search);t.set(l,e),n.replace({...n.location,search:t.toString()})}),[l,n])]}function f(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,l=m(e),[o,s]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!b({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:l}))),[i,u]=h({queryString:a,groupId:n}),[c,p]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,l]=(0,d.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&l.set(e)}),[a,l])]}({groupId:n}),f=(()=>{const e=i??c;return b({value:e,tabValues:l})?e:null})();(0,r.useLayoutEffect)((()=>{f&&s(f)}),[f]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!b({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);s(e),u(e),p(e)}),[u,p,l]),tabValues:l}}var g=a(2389);const k={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(e){let{className:t,block:a,selectedValue:l,selectValue:i,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.o5)(),p=e=>{const t=e.currentTarget,a=c.indexOf(t),n=u[a].value;n!==l&&(d(t),i(n))},m=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const a=c.indexOf(e.currentTarget)+1;t=c[a]??c[0];break}case"ArrowLeft":{const a=c.indexOf(e.currentTarget)-1;t=c[a]??c[c.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":a},t)},u.map((e=>{let{value:t,label:a,attributes:s}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:p},s,{className:(0,o.Z)("tabs__item",k.tabItem,s?.className,{"tabs__item--active":l===t})}),a??t)})))}function v(e){let{lazy:t,children:a,selectedValue:n}=e;const l=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function C(e){const t=f(e);return r.createElement("div",{className:(0,o.Z)("tabs-container",k.tabList)},r.createElement(y,(0,n.Z)({},e,t)),r.createElement(v,(0,n.Z)({},e,t)))}function T(e){const t=(0,g.Z)();return r.createElement(C,(0,n.Z)({key:String(t)},e))}const w={tabItem:"tabItem_Ymn6"};function S(e){let{children:t,hidden:a,className:n}=e;return r.createElement("div",{role:"tabpanel",className:(0,o.Z)(w.tabItem,n),hidden:a},t)}const D={},L="LakeSoul CDC Ingestion Table",E={unversionedId:"Usage Docs/cdc-ingestion-table",id:"Usage Docs/cdc-ingestion-table",title:"LakeSoul CDC Ingestion Table",description:"CDC (Change Data Capture) is an important data source for Lakehouse. The goal of LakeSoul CDC ingestion table is to sync the change of online OLTP database into LakeSoul in a very low latency, usually several minutes, manner so that the downstream analytics could get the newest results as soon as possible without the need of tranditional T+1 database dump.",source:"@site/docs/03-Usage Docs/04-cdc-ingestion-table.mdx",sourceDirName:"03-Usage Docs",slug:"/Usage Docs/cdc-ingestion-table",permalink:"/docs/Usage Docs/cdc-ingestion-table",draft:!1,editUrl:"https://github.com/lakesoul-io/LakeSoul/tree/main/website/docs/03-Usage Docs/04-cdc-ingestion-table.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Basic API Docs",permalink:"/docs/Usage Docs/api-docs"},next:{title:"LakeSoul Flink CDC Synchronization of Entire MySQL Database",permalink:"/docs/Usage Docs/flink-cdc-sync"}},N={},I=[{value:"Create LakeSoul CDC Ingestion Table",id:"create-lakesoul-cdc-ingestion-table",level:2},{value:"Incremental Read for LakeSoul CDC Table",id:"incremental-read-for-lakesoul-cdc-table",level:2}],O={toc:I},P="wrapper";function _(e){let{components:t,...a}=e;return(0,l.kt)(P,(0,n.Z)({},O,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"lakesoul-cdc-ingestion-table"},"LakeSoul CDC Ingestion Table"),(0,l.kt)("p",null,"CDC (Change Data Capture) is an important data source for Lakehouse. The goal of LakeSoul CDC ingestion table is to sync the change of online OLTP database into LakeSoul in a very low latency, usually several minutes, manner so that the downstream analytics could get the newest results as soon as possible without the need of tranditional T+1 database dump. "),(0,l.kt)("p",null,"LakeSoul uses an extra change operation column (column name is configurable) to model the CDC data and can consume the CDC sources including ",(0,l.kt)("a",{parentName:"p",href:"https://debezium.io/"},"Debezium"),", ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/alibaba/canal"},"canal")," as well as ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/ververica/flink-cdc-connectors"},"Flink CDC"),"."),(0,l.kt)("p",null,"To create a LakeSoul CDC ingestion table, add a table property ",(0,l.kt)("inlineCode",{parentName:"p"},"lakesoul_cdc_change_column")," with the column name that records the change type. This column should be of ",(0,l.kt)("inlineCode",{parentName:"p"},"string")," type and contains one of the three values: ",(0,l.kt)("inlineCode",{parentName:"p"},"update"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"insert"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"delete"),"."),(0,l.kt)("p",null,"During merge of the read job, only the newest records of type ",(0,l.kt)("inlineCode",{parentName:"p"},"update")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"insert")," would be kept and the ",(0,l.kt)("inlineCode",{parentName:"p"},"delete")," type records would be filtered out automatically."),(0,l.kt)("h2",{id:"create-lakesoul-cdc-ingestion-table"},"Create LakeSoul CDC Ingestion Table"),(0,l.kt)("p",null,"Use Scala API or SQL, assuming change operation column name is ",(0,l.kt)("inlineCode",{parentName:"p"},"change_type"),":"),(0,l.kt)(T,{defaultValue:"Scala",values:[{label:"Scala",value:"Scala"},{label:"SQL",value:"SQL"}],mdxType:"Tabs"},(0,l.kt)(S,{value:"Scala",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import com.dmetasoul.lakesoul.tables.LakeSoulTable\nLakeSoulTable.createTable(data, path).shortTableName("cdc_ingestion").hashPartitions("id").hashBucketNum(2).rangePartitions("rangeid").tableProperty("lakesoul_cdc_change_column" -> "change_type").create()\n'))),(0,l.kt)(S,{value:"SQL",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE table_name (id string, date string, change_type string) USING lakesoul\n  PARTITIONED BY (date)\n  LOCATION 's3://lakesoul-bucket/table_path'\n  TBLPROPERTIES('lakesoul_cdc_change_column'='change_type',\n    'hashPartitions'='id',\n    'hashBucketNum'='2');\n")))),(0,l.kt)("p",null,"Note that LakeSoul CDC ingestion table must have primary key(s) and the primary keys(s) should be the same with the online OLTP table."),(0,l.kt)("h2",{id:"incremental-read-for-lakesoul-cdc-table"},"Incremental Read for LakeSoul CDC Table"),(0,l.kt)("p",null,"The LakeSoul adopts the primary key sharding mode for incremental upsert, so the incremental data does not need to be merged with the stock data when writing. For CDC tables, the delta data is the content of the original CDC stream. The CDC incremental read of the LakeSoul table can fully retain the CDC operation flags, namely insert, update, and delete. The current version 2.2.0 already supports incremental streaming reading in Spark. The next version will release Flink Stream Source, which supports streaming incremental reading as Flink ChangeLog Stream."))}_.isMDXComponent=!0}}]);