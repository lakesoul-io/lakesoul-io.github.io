"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=u(a),m=r,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||l;return a?n.createElement(h,o(o({ref:t},c),{},{components:a})):n.createElement(h,o({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,o=new Array(l);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[d]="string"==typeof e?e:r,o[1]=i;for(var u=2;u<l;u++)o[u]=a[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},3894:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>I,contentTitle:()=>L,default:()=>_,frontMatter:()=>D,metadata:()=>N,toc:()=>E});var n=a(7462),r=a(7294),l=a(3905),o=a(6010),i=a(2466),s=a(6550),u=a(1980),c=a(7392),d=a(12);function p(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function m(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??p(a);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function h(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function b(e){let{queryString:t=!1,groupId:a}=e;const n=(0,s.k6)(),l=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,u._X)(l),(0,r.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(n.location.search);t.set(l,e),n.replace({...n.location,search:t.toString()})}),[l,n])]}function f(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,l=m(e),[o,i]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:l}))),[s,u]=b({queryString:a,groupId:n}),[c,p]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,l]=(0,d.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&l.set(e)}),[a,l])]}({groupId:n}),f=(()=>{const e=s??c;return h({value:e,tabValues:l})?e:null})();(0,r.useLayoutEffect)((()=>{f&&i(f)}),[f]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!h({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);i(e),u(e),p(e)}),[u,p,l]),tabValues:l}}var g=a(2389);const k={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(e){let{className:t,block:a,selectedValue:l,selectValue:s,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,i.o5)(),p=e=>{const t=e.currentTarget,a=c.indexOf(t),n=u[a].value;n!==l&&(d(t),s(n))},m=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const a=c.indexOf(e.currentTarget)+1;t=c[a]??c[0];break}case"ArrowLeft":{const a=c.indexOf(e.currentTarget)-1;t=c[a]??c[c.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":a},t)},u.map((e=>{let{value:t,label:a,attributes:i}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:p},i,{className:(0,o.Z)("tabs__item",k.tabItem,i?.className,{"tabs__item--active":l===t})}),a??t)})))}function v(e){let{lazy:t,children:a,selectedValue:n}=e;const l=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function C(e){const t=f(e);return r.createElement("div",{className:(0,o.Z)("tabs-container",k.tabList)},r.createElement(y,(0,n.Z)({},e,t)),r.createElement(v,(0,n.Z)({},e,t)))}function S(e){const t=(0,g.Z)();return r.createElement(C,(0,n.Z)({key:String(t)},e))}const w={tabItem:"tabItem_Ymn6"};function T(e){let{children:t,hidden:a,className:n}=e;return r.createElement("div",{role:"tabpanel",className:(0,o.Z)(w.tabItem,n),hidden:a},t)}const D={},L="LakeSoul CDC Ingestion Table",N={unversionedId:"Usage Docs/cdc-ingestion-table",id:"Usage Docs/cdc-ingestion-table",title:"LakeSoul CDC Ingestion Table",description:"CDC (Change Data Capture) is an important data source for Lakehouse. The goal of LakeSoul CDC ingestion table is to sync the change of online OLTP database into LakeSoul in a very low latency, usually several minutes, manner so that the downstream analytics could get the newest results as soon as possible without the need of tranditional T+1 database dump.",source:"@site/docs/03-Usage Docs/04-cdc-ingestion-table.mdx",sourceDirName:"03-Usage Docs",slug:"/Usage Docs/cdc-ingestion-table",permalink:"/docs/Usage Docs/cdc-ingestion-table",draft:!1,editUrl:"https://github.com/lakesoul-io/LakeSoul/tree/main/website/docs/03-Usage Docs/04-cdc-ingestion-table.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Spark API Docs",permalink:"/docs/Usage Docs/api-docs"},next:{title:"LakeSoul Flink CDC Synchronization of Entire MySQL Database",permalink:"/docs/Usage Docs/flink-cdc-sync"}},I={},E=[{value:"Create LakeSoul CDC Ingestion Table",id:"create-lakesoul-cdc-ingestion-table",level:2},{value:"In Spark",id:"in-spark",level:3},{value:"In Flink",id:"in-flink",level:3},{value:"Incremental Read for LakeSoul CDC Table",id:"incremental-read-for-lakesoul-cdc-table",level:2}],O={toc:E},P="wrapper";function _(e){let{components:t,...a}=e;return(0,l.kt)(P,(0,n.Z)({},O,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"lakesoul-cdc-ingestion-table"},"LakeSoul CDC Ingestion Table"),(0,l.kt)("p",null,"CDC (Change Data Capture) is an important data source for Lakehouse. The goal of LakeSoul CDC ingestion table is to sync the change of online OLTP database into LakeSoul in a very low latency, usually several minutes, manner so that the downstream analytics could get the newest results as soon as possible without the need of tranditional T+1 database dump. "),(0,l.kt)("p",null,"LakeSoul uses an extra change operation column (column name is configurable) to model the CDC data and can consume the CDC sources including ",(0,l.kt)("a",{parentName:"p",href:"https://debezium.io/"},"Debezium"),", ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/alibaba/canal"},"canal")," as well as ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/ververica/flink-cdc-connectors"},"Flink CDC"),"."),(0,l.kt)("p",null,"To create a LakeSoul CDC ingestion table, add a table property ",(0,l.kt)("inlineCode",{parentName:"p"},"lakesoul_cdc_change_column")," with the column name that records the change type. This column should be of ",(0,l.kt)("inlineCode",{parentName:"p"},"string")," type and contains one of the three values: ",(0,l.kt)("inlineCode",{parentName:"p"},"update"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"insert"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"delete"),"."),(0,l.kt)("p",null,"During the automatic merging phase of LakeSoul batch read data (including using Spark/Flink batch read), the latest ",(0,l.kt)("inlineCode",{parentName:"p"},"insert"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"update")," data will be kept, and ",(0,l.kt)("inlineCode",{parentName:"p"},"delete")," rows will be automatically filtered out. When using Spark/Flink streaming incremental reading, the value of the CDC change column (including ",(0,l.kt)("inlineCode",{parentName:"p"},"insert"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"update"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"delete"),") will be retained. In Flink, this column will be automatically converted to corresponding value of the RowKind field of the RowData class object, so that LakeSoul fully supports the Flink Changelog Stream semantics during Flink stream reading, and can perform incremental calculations."),(0,l.kt)("h2",{id:"create-lakesoul-cdc-ingestion-table"},"Create LakeSoul CDC Ingestion Table"),(0,l.kt)("h3",{id:"in-spark"},"In Spark"),(0,l.kt)("p",null,"Use Scala API or SQL, assuming change operation column name is ",(0,l.kt)("inlineCode",{parentName:"p"},"change_type"),":"),(0,l.kt)(S,{defaultValue:"Scala",values:[{label:"Scala",value:"Scala"},{label:"SQL",value:"SQL"}],mdxType:"Tabs"},(0,l.kt)(T,{value:"Scala",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import com.dmetasoul.lakesoul.tables.LakeSoulTable\nLakeSoulTable.createTable(data, path).shortTableName("cdc_ingestion").hashPartitions("id").hashBucketNum(2).rangePartitions("rangeid").tableProperty("lakesoul_cdc_change_column" -> "change_type").create()\n'))),(0,l.kt)(T,{value:"SQL",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE table_name (id string, date string, change_type string) USING lakesoul\n  PARTITIONED BY (date)\n  LOCATION 's3://lakesoul-bucket/table_path'\n  TBLPROPERTIES('lakesoul_cdc_change_column'='change_type',\n    'hashPartitions'='id',\n    'hashBucketNum'='2');\n")))),(0,l.kt)("p",null,"Note that LakeSoul CDC ingestion table must have primary key(s) and the primary keys(s) should be the same with the online OLTP table."),(0,l.kt)("h3",{id:"in-flink"},"In Flink"),(0,l.kt)("p",null,"Please refer to ",(0,l.kt)("a",{parentName:"p",href:"/docs/Usage%20Docs/flink-lakesoul-connector"},"Flink Connector")),(0,l.kt)("h2",{id:"incremental-read-for-lakesoul-cdc-table"},"Incremental Read for LakeSoul CDC Table"),(0,l.kt)("p",null,"The LakeSoul adopts the primary key sharding mode for incremental upsert, so the incremental data does not need to be merged with the stock data when writing. For CDC tables, the delta data is the content of the original CDC stream. The CDC incremental read of the LakeSoul table can fully retain the CDC operation flags, namely insert, update, and delete. "),(0,l.kt)("p",null,"Version 2.2.0 supports incremental streaming reading in Spark."),(0,l.kt)("p",null,"From version 2.3.0, Flink Table Source is supported, and streaming incremental reading is supported as Flink ChangeLog Stream, please refer to ",(0,l.kt)("a",{parentName:"p",href:"/docs/Usage%20Docs/flink-lakesoul-connector"},"Flink Connector")," ."))}_.isMDXComponent=!0}}]);